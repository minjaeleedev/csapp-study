# 1-9. Important Themes

## Overview

컴퓨터 시스템의 모든 측면을 관통하는 몇 가지 주요한 개념 살펴보기

## 1.9.1 Amdahl's Law

#### Concepts

시스템의 한 부분의 성능을 개선할 때, 전체 시스템에 미치는 영향은 해당 부분이 차지하는 비중과 개선 정도에 의존한다는 것

#### 개선되는 전체 실행시간

1. 기존의 전체 실행 시간 : $T_{\rm old}$
2. 개선하려는 부분이 전체에서 차지하는 비율 : $\alpha$
3. 속도 향상 비율 : $k$ (k배 개선)
4. 컴포넌트 실행 시간 = $\alpha T_{\rm old}$
5. 개선된 컴포넌트 실행 시간 = $\alpha T_{\rm old} / k$
6. 개선된 전체 실행시간
   $$ T_{\rm new} = (1-\alpha)T_{\rm old} + \alpha T_{\rm old} / k$$
    $$ = T_{\rm old}[(1-\alpha) + \alpha /k]$$

#### 속도 향상 비율

$$S:=T_{\rm old}/T_{ \rm new}$$
$$ S = {{1}\over{(1-\alpha) + \alpha / k}}$$

#### 예시

1. 전체 60%의 시간비중을 차지하는 컴포넌트의 성능을 3배 개선
2. 성능 향상 비율 = 1/[0.4+0.6/3]=1.67

#### Aside : Expressing relative performance

1. 성능 향상을 표현하는 가장 좋은 방법 : $T_{\rm old}/T_{\rm new}$ 비율
2. 실제 성능 향상이 이루어지면 해당 값은 1.0보다 큰 수가 됨
3. 접미사 'x'를 사용해서 표현 가능 : 2.2x = 2.2 times
4. 상대적 변화를 백분율로 표현하는 방법 : 변화가 작을 때는 잘 작동
   - 단점1. 정의가 모호하다. 둘 중에 무엇을 쓸 것인지?
     - $100*(T_{\rm old}-T_{\rm new})/T_{\rm new}$
     - $100*(T_{\rm{old}}-T_{\rm {new}})/T_{\rm{old}}$
   - 단점2. 변화가 클 때는 백분율 표현이 덜 직관적임
     - '성능이 120% 향상됐다' 보다는 '성능이 2.2x 향상됐다'

#### Practive Problem 1.1

트럭 운전사가 아이다호 주 보이시에서 미네소타 주 미니애폴리스까지 감자를 운송하는 일을 맡았다.
총 거리는 2,500킬로미터이고, 제한 속도를 지키며 평균 시속 100킬로미터로 운전할 수 있다고 예상하며, 이 경우 전체 운행 시간은 25시간이 소요될 것이다

1. Montana 주에서 제한 속도를 폐지했다는 뉴스를 들었다. 해당 구간은 전체 경로 중 1,500km를 차지한다. 트럭은 150km/h로 운행할 수 있다. 속도 향상 비율은?

- $\alpha=1500/2500=0.6$, $k=150/100=1.5$
- $1/[(1-\alpha)+\alpha/k]=1/(0.4+0.4)=5/4=1.25$

2. 전체 여행에서 1.67배의 속도 향상을 얻으려면, Montana 구간에서 얼마의 속도로 주행해야 하는가?

- $\alpha=0.6, S=1.67=5/3$
- $(1-\alpha) + \alpha/k=0.6=0.4+0.6/k$
- $k = 3$
- $v_{\rm new}=300\rm km / \rm h$

#### Practive Problem 1.2

한 자동자 제조회사가 고객에게 다음 출시할 신형 엔진이 4배의 성능 향상을 보여줄 것이라고 약속했다.
엔진의 90% 부분만 개선 가능하다고 결정을 내린 상태이다.
전체 엔진의 성능 목표를 달성하려면, 해당 부분을 얼마만큼(어느 k 수만큼) 향상시켜야 하는가?

- $1/4 = (1-\alpha) + {\alpha}/k = 0.1+0.9/k$
- $k = 6$

#### Special case - k to infinity

1. k를 무시할 수 있는 수준의 시간으로 바꾼다면?

$$ S\_{\infin} = {{1} \over {(1-\alpha)}}$$

2. 전체 시스템의 60%에 걸리는 시간을 무시할 수 있을 정도로 만들어도, 전체 성능 향상은 2.5배

#### Conclusion

- 전체 시스템의 속도를 향상시키려면, 시스템에서 가장 큰 비중을 차지하는 부분의 속도를 개선해야 함
- 어떤 프로세스든 개선할 때 적용할 수 있는 일반적 원칙 설명

## 1.9.2 Concurrency and Parallelism

#### Overview

1. **동시성(concurrency)**: 시스템 내에서 여러 작업이 동시에 실행되는 일반적인 개념을 가리킬 때 사용하는 용어
2. **병렬성(parallelism)**: 동시성을 활용하여 시스템의 실행 속도를 높이는 것을 의미
3. 컴퓨터 시스템에서는 다양한 추상화 수준에서 병렬성을 활용할 수 있음
    - 멀티프로세서 병렬성 (Multiprocessing, Multicore)
    - 멀티스레딩 (Hyperthreading 등)
    - 명령어 수준 병렬성 (Instruction-Level Parallelism, ILP, Superscalar)
    - 데이터 수준 병렬성 (SIMD)

#### Thread-Level Concurrency

1. 프로세스 & 스레드를 통한 동시성
   1. 프로세스 추상화 : 여러 프로그램이 동시에 실행되는 시스템 설계
   2. 스레드 : 한 개의 프로세스 내에서도 여러 제어 흐름을 동시에 실행
2. 단일 프로세서 시스템(uniprocessor system)
   1. 시분할(time-sharing)을 통한 동시실행 지원
      - 실제로는 단일 컴퓨터가 실행 중인 여러 프로세스 사이를 빠르게 전환
3. 동시성 기반 상호작용
   1. 많은 유저가 동시에 시스템과 상호작용
   2. 단일 유저가 여러 작업을 수행하는 상호작용
4. **다중 프로세서 시스템(multiprocessor system)**
   1. 하나의 OS 커널 제어 하에 여러 프로세서로 구성된 시스템
   2. 80년대부터 사용, but 멀티코어 + 하이퍼스레딩 이후로 일반적 형태가 됨
   3. 장점
      - 여러 작업 수행 시 동시성 시뮬레이션 필요성을 줄여줌
      - 단일 애플리케이션 프로그램의 실행 속도 향상(프로그램이 효과적으로 병렬 실행 가능한 여러 스레드로 작성된 경우)
   4. 멀티코어 + 하이퍼스레딩의 등장 이후, 하드웨어가 제공하는 스레드 수준 병렬성을 활용하는 애플리케이션 프로그램 작성 방법이 각광받음
5. **다중코어 프로세서** : 여러 개 CPU를 하나의 IC 칩 위에 통합한 것
   1. 4개의 CPU 코어가 있는 예시
   2. 각 코어는 자체 L1, L2 캐시를 갖고 있음
   3. L1 캐시는 두 개로 나뉨
      - 최근에 가져온 명령어 저장(i-cache)
      - 최근 데이터 저장(d-cache)
   4. 코어들은 고수준 캐시(L3 등)와 메인메모리 인터페이스를 공유
   5. 앞으로 하나의 칩에 수십-수백 개 코어 집적 예상
6. **하이퍼스레딩(Hyperthreading)**
   1. 동시 다중 스레딩(simultaneous multi-threading, SMT)
   2. 단일 CPU가 여러 제어 흐름을 동시에 실행할 수 있게 하는 기술
   3. 프로그램 카운터, 레지스터 파일 같은 CPU 하드웨어 구성요소는 여러 복사본 가짐
   4. 부동 소수점 연산 유닛 같은 구성요소는 단일 복사본만 유지
   5. 전통적인 프로세서는 스레드 전환에 20,000 클럭 사용
   6. 하이퍼스레드 프로세서는 클럭 사이클마다 어떤 스레드 실행할지 결정
   7. 처리 예시
      - 하나의 스레드가 데이터를 캐시에 로드하기 위해 대기
      - CPU는 다른 스레드 실행을 계속 진행 가능
   8. 실제 프로세서 : Intel Core i7
      - 각 코어가 두 개 스레드 실행
      - 4코어 시스템은 실제 8개 스레드를 병렬로 실행 가능

#### Instruction-Level Parallelism

1. **명령어 수준 병렬성(ILP)**
   1. 저수준 추상화 관점에서, 현대 프로세서는 한 번에 여러 명령어 실행 가능
   2. 예전 프로세서 : Intel 8086
       - 한 명령어 실행에 3-10 사이클 필요
       - 최근의 프로세서는 한 클럭당 2-4개의 명령어 수행
2. 한 명령어 시작 - 완료까지 여전히 20 사이클 이상 소요 가능
2. 여러 기법 사용해서 한 사이클에 100개에 달하는 명령어 동시 처리 가능
3. **파이프라이닝(pipelining)**
   1. 명령어 실행에 필요한 작업을 여러 단계로 나눔
   2. 프로세서 하드웨어를 나눠진 단계들이 연속으로 수행되도록 구성
   3. 각 단계는 서로 다른 명령어의 서로 다른 부분을 병렬로 처리
   4. 이를 통해 클럭 사이클 당 1개 명령어 실행 속도까지 달성하는 예시 있음
5. **슈퍼스칼라 프로세서(superscalar processor)**
   1. 클럭 사이클당 1개 이상 명령어를 지속적으로 실행 가능한 프로세서
   2. 대부분 현대 프로세서는 슈퍼스칼라 동작 지원
   3. 슈퍼스칼라 모델 활용하면 애플리케이션 프로그래머들이 자신의 프로그램 성능 이해할 수 있음
      - 생성된 코드가 더 높은 수준의 ILP 달성하도록 프로그램 작성 가능

#### Single-Instruction, Multiple-Data (SIMD) Parallelism
1. 단일 명령어, 다중 데이터(SIMD) 병렬성
   1. 가장 저수준에서 하나의 명령어가 여러 연산을 병렬로 수행하도록 함
      - 많은 현대적인 프로세서들이 이를 위한 특수 하드웨어를 갖고 있음
   2. Intel, AMD 프로세서
      - 하나의 명령어로 8개 쌍의 단정도 부동소수점 수 덧셈을 병렬로 수행하는 명령어 제공
2. SIMD 활용 : 주로 이미지, 사운드, 비디오 데이터 처리하는 애플리케이션 성능 향상
3. 컴파일러와 SIMD
   - 일부 컴파일러는 C 프로그램에서 자동으로 SIMD 병렬성 추출
   - 신뢰할 수 있는 방법 : gcc 같은 컴파일러가 지원하는 특수 벡터 데이터 타입 사용해서 프로그램 작성
   - [Web Aside OPT:SIMD](https://csapp.cs.cmu.edu/3e/waside/waside-simd.pdf)

## 1.9.3 The Importance of Abstractions in Computer Systems